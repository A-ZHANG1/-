1. 156//给定一个二叉树，其中所有的右节点要么是具有兄弟节点（拥有相同父节点的左节点）的叶节点，要么为空，将此二叉树上下翻转并将它变成一棵树， 原来的右节点将转换成左
  叶节点。返回新的根。 
  ```{java}
  // 左->根，右->左,根->右
  public TreeNode upsideDownBinaryTree(TreeNode root) {
          if(root == null || root.left == null) return root;
          TreeNode l = root.left, r = root.right;
          TreeNode res = upsideDownBinaryTree(l);
          l.left = r;
          l.right = root;
          root.left = null;
          root.right = null;
          return res;
      }
    // O(?)
```
2. 157 //给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。 
```{java}
public int read(char[] buf, int n) {
        int res = 0, cur = 0;
        char[] tmp = new char[4];
        while((cur = read4(tmp)) != 0){
            for (int i = 0; i < cur && res < n; i++) {
                buf[res] = tmp[i];
                res ++;
            }
        }
        return res;
    }
```
3. 158//给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。注意：你的 read 方法可能会被调用多次。 
```{java}
int i = 0, size = 0; // tmp, read4() return length
    char[] tmp = new char[4];

    public int read(char[] buf, int n) {
        int idx = 0; // buf
        while(idx < n){
            if(size == 0){
                size = read4(tmp);
                if(size == 0) break;
            }
            while(idx < n && i < size){
                buf[idx ++] = tmp[i ++];
            }
            if(size == i){
                i = 0; size = 0;
            }
        }
        return idx;
    }
```
4. 159 // 给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。 
```{java}
public int lengthOfLongestSubstringTwoDistinct(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int l = 0, r = 0, res = 0;
        char[] sArr = s.toCharArray();
        for (int i = 0; i < sArr.length; i++) {
            char c = sArr[i];
            if(map.keySet().contains(c)) map.put(c, i);
            else{
                if(map.keySet().size() >= 2){
                    int del_idx = Collections.min(map.values());
                    map.remove(s.charAt(del_idx));
                    l = del_idx + 1;
                }

                map.put(c, i);
            }
            res = Math.max(res, i - l + 1);
//            if(res == 4) System.out.println(i+","+l+","+map);
        }
        return res;
    }

```
5. 161//给定两个字符串 s 和 t，判断他们的编辑距离是否为 1。 插入、删除、替换
```
public boolean isOneEditDistance(String s, String t) {
        if(s.length() < t.length()){
            String tmp = s;s = t;t = tmp;
        }
        if(s.length() - t.length() > 1) return false;
        for (int i = 0; i < t.length(); i++) {
            if(s.charAt(i) != t.charAt(i)){
                if(s.length() == t.length()) return s.substring(i + 1).equals(t.substring(i + 1));
                else return s.substring(i + 1).equals(t.substring(i));
            }
        }
        return s.length() - 1 ==  t.length(); // "c" "c"; "a" ""; "A" "a";
    }
```
6. 163//给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。 
```
public List<String> findMissingRanges(int[] nums, int lower, int upper) {

        List<String> res = new ArrayList<>();
//        if(nums.length == 0) return res; // []
        int pre = lower - 1; // [], 1, 1
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] - pre == 2) res.add(String.valueOf(pre + 1));
            else if(nums[i] - pre > 2) res.add((pre + 1)+ "->" + (nums[i] - 1));
            pre = nums[i];
        }
        if(upper - pre == 1)res.add(String.valueOf(pre + 1));
        else if(upper - pre > 1)res.add((pre + 1)+ "->" + upper);
        return res;
    }
```
7.244
```
map.put(words[i], new ArrayList<Integer>(Arrays.asList(i)));
```
8.245 246 247 250
```
int count = 0;
    public int countUnivalSubtrees(TreeNode root) {
        if (root == null) return 0;
        isUnival(root);
        return count;
    }

    private boolean isUnival(TreeNode root) {
        if (root == null) return true;
        if(isUnival(root.left) &  isUnival(root.right)){// 不可以短路掉！！
            if(root.left != null && root.left.val != root.val) return false;
            if(root.right != null && root.right.val != root.val) return false;
            count ++;
            return true;
        }
        return false;
    }
   ```
   9.248 //Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
   中心对称数
   ```
public int strobogrammaticInRange(String low, String high) {
        int l = low.length(), h = high.length(), res = 0;
        List<String> candidates = new ArrayList<>();
        for (int i = l; i <= h; i++) {
            candidates.addAll(helper(i, i));
        }
        for(String c: candidates){
            if(c.length() == l && c.compareTo(low) < 0 || c.length() == h && c.compareTo(high) > 0) continue;
//            System.out.println(c);
            res++;
        }
        return res;
    }
    public List<String> helper(int n, int max){
        if(n == 0) return new ArrayList<String>(Arrays.asList(""));
        if(n == 1) return new ArrayList<String>(Arrays.asList("0","1","8"));
        List<String> res = new ArrayList<>();
        List<String> list = helper(n - 2, max);
        for (String s: list) {
            if(n != max) res.add("0" + s + "0");
            res.add("1" + s + "1");
            res.add("8" + s + "8");
            res.add("6" + s + "9");
            res.add("9" + s + "6");
        }
        return res;
    }
```
10. 249 将移位相同的字符串放到同一个list里返回.认为成环.
// 输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]
//输出：
//[
//  ["abc","bcd","xyz"],
//  ["az","ba"], // !! 0,26和0,-1
//  ["acef"],
//  ["a","z"]
//]

```
public List<List<String>> groupStrings(String[] strings) {
        Map<String, List<String>> map = new HashMap<>();
        for(String s: strings){
            String encode = "0";
            for (int i = 1; i < s.length(); i++) {
                int tmp = s.charAt(i) - s.charAt(0);
                if(tmp < 0) tmp += 26; // 成环的处理
                encode += tmp;
                encode += ",";
            }
            List<String> cur = map.getOrDefault(encode, new ArrayList<String>());
            cur.add(s);
            map.put(encode, cur);
        }
//        System.out.println(map);
        return new ArrayList<>(map.values());
    }
```
11. 252//设计实现二维数组hasNext()函数
```
1. 压扁到list里 时间O(N + v) 空间O(N)
2. 双指针 时间O(v) 空间O(1) ？？ 

```
12.253//给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免
   //会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 
```java
class Solution{
    public int minMeetingRooms(int[][] intervals) {
            int res = 0;
            Arrays.sort(intervals, new Comparator<int[]>(){
                @Override
                public int compare(int[] o1, int[] o2){
                    return o1[0] - o2[0];
                }
            });
    //        for(int[] i: intervals) System.out.println(Arrays.toString(i));
            PriorityQueue<Integer> pq = new PriorityQueue<>();
            for(int[] i: intervals){
                if(!pq.isEmpty() && i[0] >= pq.peek()){
                    pq.poll();
                }
                pq.add(i[1]);
            }
            return pq.size();
        }
}

```
13. 254// 请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。 
```
    // 和39类似的回溯算法。需要有返回值。
    public List<List<Integer>> getFactors(int n) {
        return dfs(2, n);
    }
    public List<List<Integer>> dfs(int start, int num){
        if(num == 1) return new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        for(int i = start;i <= Math.sqrt(num);i ++){
            if(num % i == 0){
                List<Integer> cur = new ArrayList<>();
                cur.add(i);
                cur.add(num / i);
                res.add(cur);
                
                List<List<Integer>> resI = dfs(i, num/i);
                for(List<Integer> list:resI){
                    list.add(i);
                    res.add(list);
                }
            }
        }
        return res;
    }

```

14. 255:  由前序遍历判断二叉排序数是否符合条件
```
// 二叉树前序遍历的栈解法
   class Solution {
       public List<Integer> preorderTraversal(TreeNode root) {
           List<Integer> res = new ArrayList<Integer>();
           if (root == null) {
               return res;
           }
   
           Deque<TreeNode> stack = new LinkedList<TreeNode>();
           TreeNode node = root;
           while (!stack.isEmpty() || node != null) {
               while (node != null) {
                   res.add(node.val);
                   stack.push(node);
                   node = node.left;
               }
               node = stack.pop();
               node = node.right;
           }
           return res;
       }
   }
//  本题的单调栈解法：

// low是当前的lower bound, pop出来说明左边扫完了，不可能出现更小的了，所以更新low. 若是遇到比low还小就说明不是preorder.
public boolean verifyPreorder(int[] preorder) {
        Deque<Integer> stack = new ArrayDeque<>();
        int low = Integer.MIN_VALUE;
        for (int i :preorder) {
            if(i < low) return false;
            while(!stack.isEmpty() && stack.peek() < i) low = stack.pop();
            stack.push(i);
        }
        return true;
    }
```

15. 261 判断无向图是否是图 是否有环
```
//1-dfs。需要记录parent，如果neighbor != parent才返回去遍历parent的邻接表
Map<Integer,Set<Integer>> map = new HashMap<>();
    boolean[] visited;
    public boolean validTree(int n, int[][] edges) {
        visited = new boolean[n];
        for(int[] e: edges){
            Set<Integer> e0 = map.getOrDefault(e[0], new HashSet<>());
            e0.add(e[1]);
            Set<Integer> e1 = map.getOrDefault(e[1], new HashSet<>());
            e1.add(e[0]);
            map.put(e[0], e0);
            map.put(e[1], e1);
        }
//        System.out.println(map);
        if(!dfs(0, -1)) return false;
        for(boolean b: visited) if(!b) return false;
        return true;
    }
    public boolean dfs(int i, int pre){
//    public void dfs(int i){
//        if(i == pre) return true;
        if(visited[i]) return false;
        visited[i] = true;
        if(map.get(i) == null) return true;
        for(int nei: map.get(i)) {
            if((nei != pre) && !dfs(nei, i)) return false;
        }
        return true;
    }
//2-bfs
//3-union find
// 

```
// TODO: dfs的迭代(stack)写法和递归写法
16. 265 粉刷房子，共K种颜色，相邻房子不能相同颜色
```
//滚动数组
public int minCostII(int[][] costs) {
        if(costs == null || costs.length == 0) return 0;
        int minCost1 = 0, minCost2 = 0, lastColor = -1;
        for(int[] cost: costs){
            int curMin1 = Integer.MAX_VALUE, curMin2 = Integer.MAX_VALUE, curColor = -1;
            for (int i = 0; i < costs[0].length; i++) {
                int curCost = cost[i] + (i == lastColor? minCost2: minCost1); // 是否能包含当前项
                if(curCost < curMin1){
                    curColor = i;
                    curMin2 = curMin1;
                    curMin1 = curCost;
                }else if(curCost < curMin2){
                    curMin2 = curCost;
                }
            }
            minCost1 = curMin1;
            minCost2 = curMin2;
            lastColor = curColor;
//            System.out.println(minCost1 +","+ minCost2 +","+ lastColor);
        }
        return minCost1;
    }
    // ？空间O(1),时间O(n3)->O(n2)
```
17. 271 字符串编解码
```
// encode字符串长度
// Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for(String s: strs){
            int len = s.length();
            sb.append(len);
            sb.append('#');
            sb.append(s);
        }
        System.out.println(sb.toString());
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> res = new ArrayList<>();
        int idx = 0, len = 0, slash = 0;
        while(idx < s.length()){
            slash = s.indexOf('#', idx);//
            len = Integer.valueOf(s.substring(idx, slash));
//            System.out.println(s.length() + ","+ (slash) + "," + (len));
            String cur = s.substring(slash + 1, slash + len + 1);
            res.add(cur);
            idx = slash + len + 1;
        }
        return res;
    }

```
18. 272 最接近的二叉搜索树值
```java
class Solution{

    //利用好二叉搜索树性质，remove堆顶可以保证后面新加入的更接近target
    PriorityQueue<Integer> q = new PriorityQueue<>();
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
       List<Integer> res = new ArrayList<>();
       helper(root, target, k);
    //        System.out.println(q);
       while(!q.isEmpty()) res.add(q.poll());
       return res;
    }
    public void helper(TreeNode root, double target, int k){
       if(root == null) return;
       helper(root.left, target, k);
       double cur = Math.abs(root.val - target);
    //        System.out.println(root.val+","+ cur);
       if(q.size() < k) q.add(root.val);
       else {
           if (cur < Math.abs(q.peek() - target)) { 
    //                System.out.println(root.val+","+ q.peek());
    //                System.out.println(cur+","+ (q.peek() - target));
               q.poll();
               q.add(root.val);
           }
           else {
               return; // 对搜索的剪枝
           }
       }
       helper(root.right, target, k);
    }
}
```

19. 栅栏涂色 //排列
```
public int numWays(int n, int k) {
    if(n == 0) return 0;
    int[][] dp = new int[n][2]; // 
    dp[0][0] = 0;
    dp[0][1] = k;
    for (int i = 1; i < n; i++) {
        dp[i][0] = dp[i - 1][1];// 和前一个颜色相同
        dp[i][1] = (k - 1)*(dp[i - 1][0] + dp[i - 1][1]);// 和前一个颜色不同
    }
//        for (int i = 0; i < n; i++) {
//            System.out.println(Arrays.toString(dp[i]));
//        }
    return dp[n - 1][0] + dp[n - 1][1];
}
// TODO: 状态压缩减小空间复杂度
```
20. 调用knows接口 O(n)次， 搜索名人
```
public int findCelebrity(int n) {
    int res = 0;
    for (int i = 0; i < n; i++) {
        if(knows(res, i)) res = i;
    }
    for (int i = 0; i < n; i++) {
        if(res == i) continue;
        if(knows(res, i) || !knows(i, res)) return -1;

    }
    return res;
}
```
21. 摇摆排序
```
// sort and swap, O(nlogn)
public void wiggleSort(int[] nums) {
    Arrays.sort(nums);
    int idx = 1;
    while(idx + 1 < nums.length){
        int tmp = nums[idx];
        nums[idx] = nums[idx + 1];
        nums[idx + 1] = tmp;
        idx += 2;
    }
}
// O(N)的解法
public void wiggleSort(int[] nums){
    for(int i = 1;i < nums.length;i ++){
        if(i % 2 == 0)
        else
    }
}
```
22. 二叉树的后继节点
```java
class Solution {
    Deque<TreeNode> s = new ArrayDeque<>();
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        int prev = Integer.MAX_VALUE;
        while(root != null || !s.isEmpty()){
            while(root != null) {
                s.addLast(root);
                root = root.left;
            }
            root = s.removeLast();
            if(prev == p.val) return root;
            prev = root.val;
    
            root = root.right;
        }
    
        return null;
    }
}
```
23. 墙与门（离陆地最远的岛，多源dfs）
```java
class Solution {
    Deque<int[]> q = new ArrayDeque<>();
    int WALL = -1, GATE = 0, ROOM = Integer.MAX_VALUE;
    public void wallsAndGates(int[][] rooms) {
        int[] dirs = {1, 0 , -1, 0, 1};
        int M = rooms.length, N = rooms[0].length;
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if(rooms[i][j] == GATE) q.add(new int[]{i, j});
            }
        }
//        for (int[] i : q) {
//            System.out.println(Arrays.toString(i));
//        }
        while(!q.isEmpty()){
            int[] pos = q.removeFirst();
            for (int i = 0; i < 4; i++) {
                int dx = pos[0] + dirs[i];
                int dy = pos[1] + dirs[i + 1];
//                System.out.println(dx + "," + dy);
                if(dx < 0 || dx >= M || dy < 0 || dy >= N || rooms[dx][dy] != ROOM) continue;

                rooms[dx][dy] = rooms[pos[0]][pos[1]] + 1;
//                System.out.println(dx + "," + dy);
                q.addLast(new int[]{dx, dy});
            }

        }
    }
}
```
24. 291 判断单词是否符合pattern
```java
/*
 pattern = "abab" 的第一个字符 'a' 和 str = "redblueredblue" 的回溯过程
 以 ('a' -> "r") 开始，查找 "bab" 和 "edblueredblue" 的映射关系；
 
 以 ('a' -> "re") 开始，查找 "bab" 和 "dblueredblue" 的映射关系
 
 以 ('a' -> "red") 开始，查找 "bab" 和 "blueredblue" 的映射关系
 
 复杂度： O (n^m) = n*(n-1)*... *1
 
 */
class Solution {
    Map<Character, String> map = new HashMap<>();
    public boolean wordPatternMatch(String pattern, String s) {
        if(pattern.length() == 0) return s.length() == 0;
        char c = pattern.charAt(0);
        for (int i = 1; i <= s.length() - pattern.length() + 1; i++) {
            String mapStr = map.get(c);
            String curStr = s.substring(0, i);

            if(mapStr == null && !map.containsValue(curStr) || mapStr != null && curStr.equals(mapStr)){
                map.put(c, curStr);
                if(wordPatternMatch(pattern.substring(1), s.substring(i))) return true;
                else if(mapStr == null) map.remove(c);
            }
        }
        return false;
    }
}
```
25. 294 翻转游戏，判断先翻方是否能赢
```java
// 回溯 + 记忆化
class Solution {
    Map<String, Boolean> map = new HashMap<>();
    public boolean canWin(String s) {
        if(map.containsKey(s)) return map.get(s);

        for (int i = 0; i < s.length() - 1; i++) {
            if(s.substring(i, i + 2).equals("++")){
                String ss = s.substring(0, i) + "--" + s.substring(i + 2);

                if(!canWin(ss)) { // 若下一手不能赢，则当前能赢
                    map.put(ss, false);
                    return true;
                }
                map.put(ss, true);
            }
        }
        return false;
    }
}
```
26. 296：最佳碰头地点
```java
// bfs或暴力计算汉明顿距离O(mnk),其中k为房间个数，最差时间复杂度O(m^2n^2)
// 数学规律：一定是在中位数的点
// i.e. 也许你会认为最优相遇点一定是这些 1 中的某一个。对于奇数个 1 来说确实如此。但偶数个 1 的情况却未必，就像情况 5 。你可以选择 x = 1x=1 到 x = 4x=4 之间的任意一个点作为相遇点，且距离都是最小的。
class Solution{
    public int minTotalDistance(int[][] grid) {
        List<Integer> rows = new ArrayList<>();
        List<Integer> cols = new ArrayList<>();
        for (int row = 0; row < grid.length; row++) {
            for (int col = 0; col < grid[0].length; col++) {
                if (grid[row][col] == 1) {
                    rows.add(row);
                    cols.add(col);
                }
            }
        }
        int row = rows.get(rows.size() / 2);
        Collections.sort(cols);
        int col = cols.get(cols.size() / 2);
        return minDistance1D(rows, row) + minDistance1D(cols, col);
    }
    
    private int minDistance1D(List<Integer> points, int origin) {
        int distance = 0;
        for (int point : points) {
            distance += Math.abs(point - origin);
        }
        return distance;
    }   
}

```
27. 298： 最长连续序列。（认为从父节点到子节点 才构成路径）
```java
class Solution {
    int maxLen = 0;
    public int longestConsecutive(TreeNode root) {
       return dfs(root, null, 0);
    }
    public int dfs(TreeNode root, TreeNode pre, int len){
        if(root == null) return len;
        len = (pre != null && root.val == pre.val + 1)? len + 1: 1;
        return Math.max(Math.max(len, dfs(root.left, root, len)), dfs(root.right, root, len));
    }
}
```
28. 305 并查集 不断加入新陆地的岛屿数量
```java
// TODO: 不会
```
29. 308 二维数组中的前缀和。可以用线段树，但是这里没有用
```java
class NumMatrix {
    int[][] sumRow;
    int[][] matrix;
    int M, N;
    public NumMatrix(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return; // 用例[[]].还能这样直接return
        this.matrix = matrix;
        this.M = matrix.length;
        this.N = matrix[0].length;
        this.sumRow = new int[M][N];
        for (int i = 0; i < M; i++) {
            int sum = 0;
            for (int j = 0; j < N; j++) {
                sum += matrix[i][j];
                sumRow[i][j] = sum;
            }
//            System.out.println(Arrays.toString(sumRow[i]));
        }
    }
    
    public void update(int row, int col, int val) {
        int delta = val - matrix[row][col];
        matrix[row][col] = val;
        for (int i = col; i < N; i++) {
            sumRow[row][i] += delta;
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum = 0;
        for (int i = row1; i <= row2; i++) {
//            System.out.println(sumRow[i][col1 - 1] + ","+ sumRow[i][col2]);
            sum += col1 == 0 ? sumRow[i][col2]: sumRow[i][col2] - sumRow[i][col1 - 1];
        }
        return sum;
    }
}
```
30. 302 包含黑色像素的最小矩形.懒二分
```java
class Solution {
    char[][] image;
    int m, n;
    public int minArea(char[][] image, int x, int y) {
        this.image = image;
        this.m = image.length;
        this.n = image[0].length;
        int l = findCol(0, y, 0, m, true);
        int r = findCol(y + 1, n, 0, m, false);
        int t = findRow(0, x, l, r, true);
        int b = findRow(x + 1, m, l, r, false);
        return (r - l) * (b - t);
    }
    public int findCol(int l, int r, int top, int buttom, boolean whiteToBlack){
        while(l < r){
            int mid = l + (r - l) / 2, k = top;
            while(k < buttom && image[k][mid] == '0') {
                k ++;
            }
            if(k < buttom == whiteToBlack) r = mid;
            else l = mid + 1;
         }
        return l;
    }
    public int findRow(int t, int b,int left, int right, boolean whiteToBlack){
        while(t < b){
            int mid = t + (b - t) / 2, k = left;
//            System.out.println(t + "," + b + "," + mid);
            while(k < right && image[mid][k] == '0') k ++;
            if(k < right == whiteToBlack) b = mid;
            else t = mid + 1;
        }
        return t;
    }
}
```
31. 311 系数矩阵乘法，数据结构：<rowi,<colk, val>> <colj, <rowk, val>> ixk kxj 行中k个依次与列中k个相乘 
```java
class Solution {
    public int[][] multiply(int[][] A, int[][] B) {
        int[][] res = new int[A.length][B[0].length];
        Map<Integer, Map<Integer, Integer>> mapA = transA(A);
        Map<Integer, Map<Integer, Integer>> mapB = transB(B);
//        System.out.println(mapA);
//        System.out.println(mapB);
        for (int i: mapA.keySet()) {
            Map<Integer, Integer> ri = mapA.get(i);
            for(int j: mapB.keySet()){
                Map<Integer, Integer> cj = mapB.get(j);
                for(int k: cj.keySet()){
//                    System.out.println(ri.get(j));
//                    System.out.println(cj.get(k));
                    if(ri.get(k) != null && cj.get(k) != null) res[i][j] += ri.get(k) * cj.get(k);
                }
            }
        }

        return res;
    }
    public Map<Integer, Map<Integer, Integer>> transA(int[][] A){
        Map<Integer, Map<Integer, Integer>> mapA = new HashMap<>();
        for (int i = 0; i < A.length; i++) {
            Map<Integer, Integer> row = new HashMap<>();
            for (int j = 0; j < A[0].length; j++) {
                if(A[i][j] != 0) row.put(j, A[i][j]);
            }
            mapA.put(i, row);
        }
        return mapA;
    }
    public Map<Integer, Map<Integer, Integer>> transB(int[][] B){
        Map<Integer, Map<Integer, Integer>> mapB = new HashMap<>();
        for (int j = 0; j < B[0].length; j++) {
            Map<Integer, Integer> col = new HashMap<>();
            for (int i = 0; i < B.length; i++) {
                if(B[i][j] != 0)  col.put(i, B[i][j]);
            }
            mapB.put(j, col);
        }
        return mapB;
    }
}
```
32. 314 二叉树垂直序遍历
```java
class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        Map<Integer, List<Integer>> res = new TreeMap<>();
        Deque<TreeNode> q = new ArrayDeque<>();
        Map<TreeNode, Integer> map = new HashMap<>();
        q.add(root);
        map.put(root, 0);
        while(!q.isEmpty()){
            TreeNode node = q.removeFirst();
//            for(TreeNode t: map.keySet()){
//                System.out.println(t.val+","+map.get(t));
//            }

            int idx = map.get(node); // res中的index （-2， -1， 0， 1， 2）中的哪一个
            List<Integer> cur = res.getOrDefault(idx, new ArrayList<>());
            cur.add(node.val);
            res.put(idx, cur);
            if(node.left != null){
                q.addLast(node.left);
                map.put(node.left, idx - 1);
            }
            if(node.right != null){
                q.addLast(node.right);
                map.put(node.right, idx + 1);
            }
        }
        return new ArrayList<>(res.values());
    }
}
```
33. 490 迷宫，小球撞到墙才能停下来
```java
// bfs 也要用visited的
class Solution{
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
            int M = maze.length, N = maze[0].length;
            int[][] visited = new int[M][N];
            int[] dirs = {1, 0, -1, 0, 1};
            Deque<int[]> q = new ArrayDeque<>();
            q.add(start);
            visited[start[0]][start[1]] = 1;
            while(!q.isEmpty()){
                int[] cur = q.removeFirst();
                for (int i = 0; i < 4; i++) {
                    int dx = cur[0] + dirs[i];
                    int dy = cur[1] + dirs[i + 1];
                    while(dx >= 0 && dy >= 0 && dx < M && dy < N && maze[dx][dy] == 0){
                        dx += dirs[i];
                        dy += dirs[i + 1];
                    }
                    dx -= dirs[i]; // "碰到墙壁返回"的特殊的处理
                    dy -= dirs[i + 1];
    //                System.out.println(dx+","+dy);
                    if(visited[dx][dy] == 1) continue;
                    visited[dx][dy] = 1;
                    int[] dCur = {dx, dy};
                    if(Arrays.equals(dCur, destination)) return true; // 数组相等
                    q.addLast(dCur);
                }
            }
            return false;
        }
}
```
505 问题演化：求最短路径长度
```java
// 将visited 数组替换为distance数组
// distance更新时重新将node 加入que
class Solution {
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        int M = maze.length, N = maze[0].length;
        int[][] distance = new int[M][N];
        for (int i = 0; i < M; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }
        int[] dirs = {1, 0, -1, 0, 1};
        Deque<int[]> q = new ArrayDeque<>();
        q.add(start);
        distance[start[0]][start[1]] = 0;
        while(!q.isEmpty()){
            int[] cur = q.removeFirst();

            for (int i = 0; i < 4; i++) {
                int cnt = 0;
                int dx = cur[0] + dirs[i];
                int dy = cur[1] + dirs[i + 1];
                while(dx >= 0 && dy >= 0 && dx < M && dy < N && maze[dx][dy] == 0){
                    dx += dirs[i];
                    dy += dirs[i + 1];
                    cnt ++;
                }
                dx -= dirs[i];
                dy -= dirs[i + 1];
//                cnt --; 这里不减，因为while循环之前的移动nt没加
//                System.out.println(dx+","+dy);
                if(distance[cur[0]][cur[1]] + cnt < distance[dx][dy]) {
                    distance[dx][dy] = distance[cur[0]][cur[1]] + cnt;
                    q.addLast(new int[]{dx, dy});
                }
            }
        }
//        for (int i = 0; i < M; i++) {
//            System.out.println(Arrays.toString(distance[i]));
//        }
        return distance[destination[0]][destination[1]] != Integer.MAX_VALUE? distance[destination[0]][destination[1]]: -1;
    }
}
```
499 问题演化： 求最短长度路径的表示lrud
```java
// TODO:不是表示最短，而是路径最短
class Solution {
    String MAXLENSTR = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";
    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
//        System.out.println("dldlr".compareTo("dldr") < 0);
        int M = maze.length, N = maze[0].length;
        Map<Integer, String> res = new TreeMap<>();
        String[][] distance = new String[M][N];
        for (int i = 0; i < M; i++) {
            Arrays.fill(distance[i], MAXLENSTR);
        }
        int[] dirs = {1, 0, -1, 0, 1};
        String[] dirName = {"d", "l", "u", "r"};
        Deque<int[]> q = new ArrayDeque<>();
        q.add(ball);
        distance[ball[0]][ball[1]] = "";
        while(!q.isEmpty()){
            int[] cur = q.removeFirst();

            for (int i = 0; i < 4; i++) {
                int dx = cur[0] + dirs[i];
                int dy = cur[1] + dirs[i + 1];
                while(dx >= 0 && dy >= 0 && dx < M && dy < N && maze[dx][dy] == 0){
                    if(Arrays.equals(new int[]{dx, dy}, hole)){

                        if(shorter(distance[cur[0]][cur[1]] + dirName[i],distance[dx][dy])) distance[dx][dy] = distance[cur[0]][cur[1]] + dirName[i];
//                        System.out.println("--------------------------");
//                        System.out.println(distance[dx][dy]);
//                        System.out.println("--------------------------");
                    }
                    dx += dirs[i];
                    dy += dirs[i + 1];
//                    System.out.println("--------------------------");
//                    System.out.println(distance[cur[0]][cur[1]] + dirName[i]);
//                    System.out.println(distance[dx][dy]);
//                    System.out.println((distance[cur[0]][cur[1]] + dirName[i]).compareTo(distance[dx][dy]) < 0);
//                    System.out.println("--------------------------");

                }
                dx -= dirs[i];
                dy -= dirs[i + 1];
                if(shorter(distance[cur[0]][cur[1]] + dirName[i],distance[dx][dy])) {
                    System.out.println(dx+","+dy+":"+(distance[cur[0]][cur[1]] + dirName[i]));

                    distance[dx][dy] = distance[cur[0]][cur[1]] + dirName[i];
                    q.addLast(new int[]{dx, dy});
                }
            }
        }
        for (int i = 0; i < M; i++) {
            System.out.println(Arrays.toString(distance[i]));
        }
        return distance[hole[0]][hole[1]] != MAXLENSTR? distance[hole[0]][hole[1]]: "impossible";
    }
    public boolean shorter(String s1, String s2){
        if(s1.length() > s2.length()) return false;
        else if(s1.compareTo(s2) < 0) return true;
        return false;
    }
}
```
排序
34. 1244 力扣排行榜 
addScore函数对已经在排行榜上的playerID的处理
map的valueSet是Collection.Collection如何排序
```java
class Leaderboard {
    Map<Integer, Integer> map;
    public Leaderboard() {
        map = new HashMap<>();
    }

    public void addScore(int playerId, int score) {
        if(map.containsKey(playerId)){
            map.put(playerId, map.get(playerId) + score);
        } else{
            map.put(playerId, score);
        }
    }

    public int top(int K) {
        List<Integer> scores = new ArrayList(map.values());
        Collections.sort(scores, (o1, o2)->o2-o1);
//        Collections.sort(scores, new Comparator<Integer>(){
//            @Override
//            public int compare(Integer o1, Integer o2){
//                return o2 - o1;
//            }
//        });
        int res = 0;
        for (int i = 0; i < K; i++) {
            res += scores.get(i);
        }
        return res;
    }

    public void reset(int playerId) {
        map.put(playerId, 0);
    }
}
```
35. 1229 slots1,slots2,大于duration的交集安排会议，求最早的会议区间
// TODO: 归类总结：区间问题 56,986
```java
class Solution {
    public List<Integer> minAvailableDuration(int[][] slots1, int[][] slots2, int duration) {
//        int l = 0, r = 0;
        // 按头排序
//        Arrays.sort(slots1, (o1, o2) -> o1[0] - o2[0]);
//        Arrays.sort(slots2, (o1, o2) -> o1[0] - o2[0]);
//        while(l < slots1.length && r < slots2.length){
//            int start = Math.max(slots1[l][0], slots2[r][0]);
//            if(start > slots1[l][1]) {l ++;continue;} // if..continue进入外层循环判断l小于数组长度，而不是用while
//            if(start > slots2[r][1]) {r ++;continue;}
//            if(Math.min(slots1[l][1], slots2[r][1]) - start >= duration) return Arrays.asList(start, start + duration);
//            if(slots1[l][0] < slots2[r][0]) l ++;
//            else r ++;
//        }
//        return new ArrayList<>();
//    }
    // 按尾排序
        Arrays.sort(slots1, (o1, o2) -> o1[1] - o2[1]);
        Arrays.sort(slots2, (o1, o2) -> o1[1] - o2[1]);
        int i = 0, j = 0;
        while(i < slots1.length && j < slots2.length)
        {
            int st = Math.max(slots1[i][0], slots2[j][0]);
            if (slots1[i][1] <= slots2[j][1])
            {
                if (slots1[i][1] - st >= duration) return Arrays.asList(st, st + duration);
                i ++;
            } else {
                if (slots2[j][1] - st >= duration) return Arrays.asList(st, st + duration);//返回的是list，不是int[]
                j ++;
            }
        }
        return new ArrayList<>();
    }
}
```
36. 1152
```java
// smaller函数写的还有问题
class Solution {
    public List<String> mostVisitedPattern(String[] username, int[] timestamp, String[] website) {
        HashMap<String, List<Log>> userVisitMap = new HashMap<String, List<Log>>(); // <username, visitPattern> 而且右边补鞥呢是ArrayList<Log>初始化
        HashMap<List<String>, Integer> patternTimeMap = new HashMap<List<String>, Integer>(); // <threeSeq, 出现次数>
        for (int i = 0; i < username.length; i++) {
            List<Log> curUserLog =  userVisitMap.getOrDefault(username[i], new ArrayList<>());
            curUserLog.add(new Log(username[i], timestamp[i], website[i]));
            userVisitMap.put(username[i], curUserLog);
        }
//        System.out.println(userVisitMap);

        for(String u: userVisitMap.keySet()){
            List<Log> visitPattern = userVisitMap.get(u);
            Collections.sort(visitPattern, (l1, l2) -> l1.timestamp - l2.timestamp); // 注意是Collections.sort不是Arrays.sort

//            System.out.println(visitPattern);
            List<String> threeSeq = new ArrayList<>();
            Set<List<String>> set = new HashSet<>();// 对同一用户相同访问模式去重
//            System.out.println(visitPattern.toString());
            for (int i = 0; i < visitPattern.size(); i++) {
                for (int j = i + 1; j < visitPattern.size(); j++) {
                    for (int k = j + 1; k < visitPattern.size(); k++) {
                        threeSeq = new ArrayList<>();
                        threeSeq.add(visitPattern.get(i).website);threeSeq.add(visitPattern.get(j).website);threeSeq.add(visitPattern.get(k).website);
                        if(set.contains(threeSeq)) continue;
                        set.add(threeSeq);
                        patternTimeMap.put(threeSeq, patternTimeMap.getOrDefault(threeSeq, 0) + 1);
                    }
                }
            }
        }
        List<String> res = new ArrayList<>();
//        System.out.println(patternTimeMap);
        for (List<String> pattern: patternTimeMap.keySet()) {
//            System.out.println(pattern);
            if(patternTimeMap.getOrDefault(res, 0) < patternTimeMap.get(pattern)) res = pattern;
            else if(patternTimeMap.get(res) == patternTimeMap.get(pattern)){
//                if(isTarget(pattern)) {
//                    System.out.println("here");
//                    System.out.println(smaller(pattern, res));
//
//                }
////                System.out.println("compare");
//                System.out.println(smaller(Arrays.asList("qs", "canlv", "bkro"), Arrays.asList("cahgsobjjs", "bkrok", "rugydl")));
//                System.out.println("qs".compareTo("cahgsobjjs"));
                //比较得字典序较小
                res = smaller(res, pattern);
//                System.out.println(res);
            }
        }
        return res;
    }
    public List<String> smaller(List<String> p1, List<String> p2){ //
        for (int i = 0; i < 3; i++) {
            if(p1.get(i).compareTo(p2.get(i)) < 0) return p1;
            else return p2;
        }
        return p2;
    }
//    public boolean isTarget(List<String> pattern){
//        if(!pattern.get(0).equals("cahgsobjjs") ||!pattern.get(1).equals("bkrok")||!pattern.get(2).equals("rugydl")) return false;
//        return true;
//    }
}

class Log{
    String username;
    int timestamp;
    String website;
    public Log(String usr, int ts, String w){
        this.username = usr;
        this.timestamp = ts;
        this.website = w;
    }
//    public int getTimestamp(){
//        return this.timestamp;
//    }
    public String toString(){
        return username +","+ timestamp+","+website;
    }
}
```
37. 1057 worker N个， bike M个，给每个worker找个bike,使曼哈顿距离之和最小。若两个worker到同一车距离相等，按workerid升序安排bike, 若多个Bike到同一worker距离相等，按bikeid升序安排。
```java
class Solution {
    public int[] assignBikes(int[][] workers, int[][] bikes) {
        int N = workers.length, M = bikes.length;
        Set<Integer> workerSet = new HashSet<>();
        Set<Integer> bikeSet = new HashSet<>();
        for (int i = 0; i < N; i++) workerSet.add(i);
        for (int i = 0; i < M; i++) bikeSet.add(i);

// 用heap，提前计算出所有(worker,bike) Pair距离(暴力)，做贪心
//priorityQueue 常用方法：add(), poll()
// 用set表示worker或bike已经访问
        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<>(){
            @Override
            public int compare(Pair p1, Pair p2){
                if(p1.distance != p2.distance) return p1.distance -p2.distance;
                else if(p1.worker != p2.worker) return p1.worker - p2.worker;
                else return p1.bike - p2.bike;
            }
        });
        int[] res = new int[N];

        for (int i = 0; i < N; i++) { // worker
            for (int j = 0; j < M; j++) { // bike
                pq.add(new Pair(i, j, workers[i], bikes[j]));
            }
        }

        while(workerSet.size() != 0){
            Pair p = pq.poll();
            if(workerSet.contains(p.worker) && bikeSet.contains(p.bike)){
                res[p.worker] = p.bike;
                workerSet.remove(p.worker);
                bikeSet.remove(p.bike);
            }
        }
        return res;
    }

}
class Pair{
    int worker;
    int bike;
    int distance;
    public Pair(int w, int b, int[] wpos, int[] bpos){
        this.worker = w;
        this.bike = b;
        this.distance = distance(wpos, bpos);
    }
    public int distance(int[] wpos, int[] bpos){
        return Math.abs(wpos[0] - bpos[0]) +  Math.abs(wpos[1] - bpos[1]);
    }
}
```
38. 1099 数组中小于k的两数之和的最大值
```java
// 只在num[l]+num[r] < k时更新res
// 双指针 但是不能二分 会跳过一些中间结果
class Solution {
    public int twoSumLessThanK(int[] nums, int k) {
        if(nums.length < 2) return -1;
        Arrays.sort(nums);
        System.out.println(Arrays.toString(nums));
        int l = 0, r = nums.length - 1;
        int res = -1;
        while(l < r){
            if(nums[l] + nums[r] < k) {
                res =  Math.max(res, nums[l] + nums[r]); // 指针动的时候没有从小到大的heuristic所以要童年各国上一步的值比较记录
//                System.out.println(nums[l] +","+ nums[r]);
                l ++;
            }else{
                r -- ;
            }
        }
        return res;
    }
}
```
39. 527 单词缩写： 
1、题意：前缀相同的单词做缩写的的时候需要同步增加前缀
2、将前缀相同的放到一个group中，建字典树

```java
// TODO: 字典树index上还有些小问题
class Solution {
    public List<String> wordsAbbreviation(List<String> dict) {
//        List<String> res = new ArrayList<>();
//        Set<String> abbs = new HashSet<>();
//        for(String d: dict){
//            if(d.length() < 4) {res.add(d); continue;}
//            String abb = "" + d.charAt(0) + (d.length() - 2) + d.charAt(d.length() - 1);
//            int idx = 1;
//            while(abbs.contains(abb)){
//                idx ++;
//                abb = d.substring(0, idx) + (d.length() - idx - 1) + d.charAt(d.length() - 1);
//            }
//            abbs.add(abb);
//            res.add(abb);
//        }
//        return res;
//    }
        Map<String, List<IndexedWord>> group = new HashMap<>(); // group of words with same abbrivation
        for (int i = 0; i < dict.size(); i++) {
            String abb = abbr(dict.get(i), 0);
            List<IndexedWord> groupList = group.getOrDefault(abb, new ArrayList<>());
            groupList.add(new IndexedWord(dict.get(i), i));
            group.put(abb, groupList);
        }
        System.out.println(group);
        String[] res = new String[dict.size()];
        for(List<IndexedWord> sameAbbrIWList: group.values()){
            TrieNode root = new TrieNode();
            // 对每个group建字典树
            for(IndexedWord iw: sameAbbrIWList){
                TrieNode cur = root;
                for(char ch: iw.word.toCharArray()){
                    int n = ch - 'a';
                    if(cur.next[n] == null) cur.next[n] = new TrieNode();

                    cur.cnt ++;
                    System.out.println(ch+","+cur.cnt);
                    cur = cur.next[n];
                }// ["intension","intrusion"]
            }
            // 判断节点cnt是否为1
            for(IndexedWord iw: sameAbbrIWList){
                TrieNode cur = root;
                int idx = 1;
                for(char ch: iw.word.toCharArray()){
//                    System.out.println(ch+","+cur.cnt);
                    idx ++;
                    if(cur.cnt == 1) break;
                    int n = ch - 'a';
                    cur = cur.next[n];
                }
                System.out.println(iw.word+","+idx);
                res[iw.idx] = abbr(iw.word, idx);
            }
        }
        return Arrays.asList(res);
    }
    public String abbr(String d, int idx){
        System.out.println(d+","+idx);
        if(d.length() - idx <= 3) return d;
        return d.substring(0, idx) + (d.length() - idx - 2) + d.charAt(d.length() - 1);
    }
}
class IndexedWord{
    String word;
    int idx;
    public IndexedWord(String w, int i){this.word = w;this.idx=i;}
    public String toString(){
        return word +","+idx;
    }
}
class TrieNode{
    int cnt;
    TrieNode[] next;
    public TrieNode(){
        cnt = 0;
        next = new TrieNode[26];
    }
}
```
40. 369 对链表形式表示的数字加1
```java
class Solution {
    // 最右不为9的数字加1，之后的数字全部变为0
    // 对999这样需要首位进位的数字，设置dummy节点，初始为0
    public ListNode plusOne(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode not9 = dummy;
        while(head != null){
            if(head.val != 9) not9 = head;
            head = head.next;
        }
        not9.val ++;
        not9 = not9.next;
        while(not9 != null){
            not9.val = 0;
            not9 = not9.next;
        }
        return dummy.val == 1? dummy: dummy.next;

    }
}
```
41. 379 理解题意：电话号码在[0,maxNumber)上分配.选好数据结构：boolean 数组表示该正数是否已被分配
```java
class PhoneDirectory {
    int maxNumbers;
    boolean[] used;
    /** Initialize your data structure here
        @param maxNumbers - The maximum numbers that can be stored in the phone directory. */
    public PhoneDirectory(int maxNumbers) {
        this.maxNumbers = maxNumbers;
        used = new boolean[maxNumbers];
    }
    
    /** Provide a number which is not assigned to anyone.
        @return - Return an available number. Return -1 if none is available. */
    public int get() {
        int idx = 0;
        while(idx < maxNumbers) {
            if(!used[idx]) {
                used[idx] = true;
                return idx;
            }
            idx ++;
        }
        return -1;
    }
    
    /** Check if a number is available or not. */
    public boolean check(int number) {
        return !used[number];
    }
    
    /** Recycle or release a number. */
    public void release(int number) {
        used[number] = false;
    }
}
```
42. 426原地将二叉搜索树改装为双向链表
```java
// 巧用last节点记上一个节点和 first节点用一次，记最左节点
// TODO:迭代
class Solution {
    Node first = null, last = null;
    public Node treeToDoublyList(Node root) {
        if(root == null) return root;
        helper(root);
        first.left = last;last.right = first;
        return first;
    }
    public void helper(Node node){
        if(node == null) return;
        helper(node.left);
        if(last == null){
            first = node;
        }else{
            node.left = last;last.right = node;
        }
        last = node;
        helper(node.right);
    }
}
```
43. 708 向循环升序链表中插入新值，使保持循环升序
```java
class Solution {
    // Node 的较特殊的next定义方式
    public Node insert(Node head, int insertVal) {
        if(head == null){
            head = new Node(insertVal);
            head.next = head;
            return head;
        }
        Node cur = head;
        while(true){
            // 上升区间
            if(cur.val < cur.next.val){
                if(cur.val <= insertVal && cur.next.val >= insertVal){ // [1,3,5] 3
                    cur.next = new Node(insertVal, cur.next);
                    break;
                }
            }else if(cur.val > cur.next.val){ // 下降区间(首尾相接点)
                if(cur.val <= insertVal || cur.next.val >= insertVal){
                    cur.next = new Node(insertVal, cur.next);
                    break;
                }
            } else{ // 题目说循环升序，但是还是要你考虑[3,3,3]这种情况
                //这种方式掉进"一直都是相等的点"这个情况
                // 用例[1] 2
                if(cur.next == head){
                    cur.next = new Node(insertVal, head);
                    break;
                }

            }
            cur = cur.next;
        }
        return head;
    }
}
```
44. 366 按层将 二叉树子节点放入res
```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    // 类似二叉树最大深度问题
    // 用List存每个深度的节点list
    public List<List<Integer>> findLeaves(TreeNode root) {
        height(root);
        return res;
    }
    public int height(TreeNode node){
        if(node == null) return -1;
        int h = 1 + Math.max(height(node.left), height(node.right));
        if(res.size() < h + 1) res.add(new ArrayList<>());
        // 最边缘层的节点深度为0，刚好是返回需要的顺序
        res.get(h).add(node.val);
        return h;
    }
}
```
45. 333 最大满足BST的子树的大小（子树必须包括左右子节点）
```java
// 树形dp，实现思路为后序遍历：先遍历左子树收集信息，然后右子树收集信息，头结点信息整合（详见程序员代码面试指南）
class Solution {
    // 树形dp
    public int largestBSTSubtree(TreeNode root) {
        return helper(root).size;
    }
    public Result helper(TreeNode node){
        // base case.最小值为MAX,最大值为MIN,size为0：通过返回这种节点绕过后面判断左右子树为空的逻辑
        if(node == null) return new Result(null, Integer.MIN_VALUE, Integer.MAX_VALUE, 0);
        // 收集左子树信息
        Result left = helper(node.left);
        // 收集右子树信息
        Result right = helper(node.right);
        //整合：
        // 1. 左或右子树为最大BST
        int max = Math.max(node.val, right.max); // 如果当前节点加入后不符合BST，min/max会变成奇怪的值，不能通过后续判断
        int min = Math.min(node.val, left.min);
        TreeNode maxHead = left.size >= right.size? left.maxHead: right.maxHead;
        int maxSize = Math.max(left.size, right.size);
        // 2. 以当前节点为根满足BST
        if(node.val > left.max && node.val < right.min && node.left == left.maxHead && node.right == right.maxHead){
            maxHead = node;
            maxSize = left.size + right.size + 1;
        }
        return new Result(maxHead, max, min, maxSize);
    }
}
// TODO: 下面这个lc解法有空指针报错 测试用例:[4,2,7,2,3,5,null,2,null,null,null,null,null,1]
class Solution {
    // 每个节点只遍历一次，满足题目要求的O(n)
    public int largestBSTSubtree(TreeNode root) {
        Result res = helper(root);
        return res == null ? 0: res.size;
    }
    public Result helper(TreeNode node){
        if(node == null) return null;
        Result l = node.left != null ? helper(node.left) : null;
        Result r = node.right != null ? helper(node.right) : null;
        boolean lValid = l == null || l.max < node.val;
        boolean rValid = r == null || r.min > node.val;
        if(lValid && rValid){
            // 每个属性单独初始化：l r为null的情况
            Result newRes = new Result();
            newRes.node = node;
            newRes.size = (l == null ? 0 : l.size) + (r == null ? 0 : r.size) + 1;
            newRes.min = l == null ? node.val: l.min;
            newRes.max = r == null ? node.val: r.max;
            return newRes;
        }
//        else if(lValid){ // 题目要求：子树必须包含所有后代
//            Result newRes = new Result(node, (l == null ? 0 : l.size)  + 1, (l == null ? node.val : l.min), node.val);
//            return newRes;
//        }else if(rValid){
//            Result newRes = new Result(node, (r == null ? 0 : r.size)  + 1, node.val, (r == null ? node.val  : r.max) );
//            return newRes;
//        }
        else{
            if(l != null && r != null) return l.size > r.size ? l: r;
            else if(l != null) return l;
            else if(r != null) return r;
        }

        return null;
    }
}
class Result{
    TreeNode node; // head
    int size;
    int max;
    int min;
    public Result(){

    }
    public Result(TreeNode n, int s, int ma, int mi){
        this.node = n;this.size = s;this.max=ma;this.min = mi;
    }
}
    // 法二：在每个节点上用#98,O(n)的isValid()方法判断是否满足是二叉树，总时间复杂度O(n2)
```

46. 545 打印边界节点
```java
//只打印根到最左节点的路径、叶子、根到最右节点的路径
class Solution {
    // 先序遍历变种
    TreeNode[][] heightMap; // 存每层的左右边界节点
    List<Integer> res = new ArrayList<>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        dfs(root, true, true);
        return res;
    }
    public void dfs(TreeNode node, boolean leftBound, boolean rightBound){
        if(node == null) return;
        // 处理节点，加入左边界和叶子节点
        if(leftBound) res.add(node.val);
        else if(node.left == null && node.right == null){
            res.add(node.val);
            return;
        }
        // 处理左右子树
        dfs(node.left, leftBound, !leftBound && rightBound && node.right == null);
        dfs(node.right, node.left == null && leftBound && !rightBound, rightBound);
        
        // 加入右边界
        if(!leftBound && rightBound) res.add(node.val);
    }
}


// 程序员代码面试指南：另一种打印边界(轮廓)节点
class Solution {
    TreeNode[][] heightMap; // 存每层的左右边界节点
    List<Integer> res = new ArrayList<>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {

        // 存每层的左右边界节点
        int height = height(root);
        heightMap = new TreeNode[height][2];
        getMap(root, 0);

        // 加入左边界的叶子节点
        for (int i = 0; i < height; i++) {
            res.add(heightMap[i][0].val);
        }
        // 加入非左右边界的叶子节点
        addLeaf(root, 0);
        // 加入右边界的叶子节点
        for (int i = height - 1; i >= 0; i--) {
            res.add(heightMap[i][1].val);
        }

        return res;
    }
    public void addLeaf(TreeNode node, int l){ // l for level
        if(node == null) return;
        if(node.left != null && node.right != null && node != heightMap[l][0] && node != heightMap[l][1]){
            res.add(node.val);
        }
        addLeaf(node.left, l + 1);
        addLeaf(node.right, l + 1);
    }

    public void getMap(TreeNode node, int h){
        if(node == null) return;
        if(heightMap[h][0] == null) heightMap[h][0] = node;
        heightMap[h][1] = node; // 不断覆盖最右节点
        getMap(node.left, h + 1);
        getMap(node.right, h + 1);
    }
    public int height(TreeNode node){
        if(node == null) return 0;
        return 1 + Math.max(height(node.left), height(node.right));
    }
}
```
47. 510. 二叉搜索树的后继节点。Node 有parent指针，要求不能访问node的值
```java
// 可以中序遍历序列中找洗下一个值
// 或者分情况讨论
class Solution {
    // O(L) 空间O(1)的解法
    public Node inorderSuccessor(Node node) {
        // 若存在右子树，右子树最左节点
        if(node.right != null){
            node = node.right;
            while(node.left != null) node = node.left;
            return node;
        }else{
            //不存在右子树，父节点(且当前节点为父节点的左子节点)
            while(node.parent != null && node.parent.left != node){
                node = node.parent;
            }
            return node.parent;
        }
    }
}

```

48. 从"4(2(3)(1))(6(5))"这样的字符串生成二叉树
```java
class Solution {
    //  stack解法 特别巧妙。数字入栈，)出栈，栈顶永远是当前节点的父节点
    public TreeNode str2tree(String s) {
        if(s == null || s.length() == 0) return null;
        Deque<TreeNode> stack = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == ')') stack.removeLast(); // 保证stack.peek()一直是父节点
            // 获取当前元素的值
            else if(s.charAt(i) >= '0' && s.charAt(i) <= '9' || s.charAt(i) == '-'){ // 节点可能为负值
                int start = i;
                while(i < s.length() - 1 && s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i ++; // 用i + 1因为进入外层循环i会加以

                TreeNode node = new TreeNode(Integer.valueOf(s.substring(start, i + 1)));
                System.out.println(node.val);

                // 父节点是栈顶节点
                if(!stack.isEmpty()){
                    TreeNode parent = stack.getLast();
                    if(parent.left == null) parent.left = node;
                    else parent.right = node;
                }
                // node 入栈
                stack.addLast(node);
            }
//            for(TreeNode n: stack) System.out.printf("%d, ", n.val);
//            System.out.println();
        }

        return stack.getLast();
    }
}
```
49. 428 N叉树序列化 反序列化
```java
// TODO: 暂时不会的hard
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Codec {
    // Encodes a tree to a single string.
    public String serialize(Node root) {
        if(root == null) return "";
        return encode(root).toString;
    }
    public StringBuilder encode(Node node){
        StringBuilder res = new StringBuilder();
        if(node == null) return res;
        res.append(node.val);
        res.append(" ");
        if(node.children.size() != 0){
            res.append("[");
            for(Node c: node.children) {
                encode(c);
            }
            res.append("]");
        }
        return res;
    }
	
    // Decodes your encoded data to tree.
    public Node deserialize(String data) {
        String[] strings = data.split(" ");
        for(String s: strings){
            if(s.equals("[")){

            }else if(s.equals("]")){

            }else{
                Node cur = new Node(Integer.valueOf(s));
                cur.children
            }
        }
    }
}
```
50. 360 升序排一元二次函数值
```java
// 双指针 1b/2a的距离 或简化逻辑：直接比较左右值，加入res
class Solution {
    int a, b, c;
    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {
        int N = nums.length,l = 0, r = N - 1;
        this.a = a; this.b = b; this.c = c;
        int[] res = new int[N];
        int idx = a >= 0 ? N - 1 : 0; // 如果不想重写f，a < 0就从小idx向大idx更新
        if(a >= 0){// 直线合并到这里（或者下面也行）
            while(l <= r){
                if(f(nums[l]) >= f(nums[r])) res[idx --] = f(nums[l ++]);
                else res[idx --] = f(nums[r --]);
            }
        }
        else{
            while(l <= r){
                if(f(nums[l]) <= f(nums[r])) res[idx ++] = f(nums[l ++]);
                else res[idx ++] = f(nums[r --]);
            }
        }
        return res;
    }
    public int f(int x){
        return a * x * x + b * x + c;
    }
}
```
51. 487 无限流中，最多能将一个0反转成1，形成的最长全是1的串的长度
```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int l = 0, r = 0, N = nums.length, cnt = 0, res = 0;
        while(r < nums.length){
            if(nums[r] == 0) cnt ++;
            while(cnt > 1 && l < r){
                cnt -= nums[l] == 0 ? 1 : 0;
                l ++;
            }
            r ++;
            res = Math.max(res, r - l);
//            System.out.println(l +","+ r +","+ (r - l));
        }
        return res;
    }
}
```
52. 702 不知道右边界的数组中找target的下标
```java
//法1. 分析：元素值域[-9999,9999],元素值互不相同，因此数组最大长度为20000。right从2w开始
// 法2.初始化right = 1,不断扩展右边界r = r >> 1直到arr[r] > target
class Solution {
    public int search(ArrayReader reader, int target) {
        int l = 0, r = 1;
        while(reader.get(r) < target) { // 注意ArrayReader.get()的调用方式
            l = r;// 左边界也可以跟着放缩
            r <<= 1;
        }
        while(l < r){
            int mid = l + (r - l) / 2;
            if(reader.get(mid) < target) l = mid + 1;
            else r = mid;
        }
        return reader.get(l) == target ? l: -1;
    }
}
```
53. 723 连续三个糖果可消除
```java
// 标记可消除点为负值，成ad hoc图（临时中间图）
class Solution {
    public int[][] candyCrush(int[][] board) {
        boolean todo = false; // 是否有可消除，是否需要尾递归
        int M = board.length, N = board[0].length;
        // 每行中标记为负值代表可消除
        for (int r = 0; r < M; r++) {
            for (int c = 2; c < N; c++) {
                int v = Math.abs(board[r][c]);
                if(v != 0 && Math.abs(board[r][c - 1]) == v && Math.abs(board[r][c - 2]) == v){
                    board[r][c] = board[r][c - 1] = board[r][c - 2] = -v;
                    todo = true;
                }
            }
        }
        // 每列中标记为负值代表可消除
        for (int r = 2; r < M; r++) {
            for (int c = 0; c < N; c++) {
                int v = Math.abs(board[r][c]);
                if(v != 0 && Math.abs(board[r - 1][c]) == v && Math.abs(board[r - 2][c]) == v){
                    board[r][c] = board[r - 1][c] = board[r - 2][c] = -v;
                    todo = true;
                }
            }
        }
        // 每列从下至上消除负数
        for (int c = 0; c < N; c++) { // 按列号循环
            int rIdx = M - 1;
            for (int r = M - 1; r >= 0 ; r--) {
                if (board[r][c] > 0) {
                    board[rIdx --][c] = board[r][c];
                }
            }
            while(rIdx >= 0) board[rIdx --][c] = 0;
        }
        return todo? candyCrush(board) : board;
    }
}
```
54. 1213 求同时在三个数组中出现的整数，三指针
```java
class Solution {
    public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {
        List<Integer> res = new ArrayList<>();
        int i = 0, j = 0,k = 0;
        while(i < arr1.length && j < arr2.length && k < arr3.length){
            if(arr1[i] == arr2[j] && arr2[j] == arr3[k]) {
                res.add(arr1[i]);
                i ++; j ++; k ++;
                continue;
            }
            int minVal = Math.min(Math.min(arr1[i], arr2[j]), arr3[k]);
            if(arr1[i] == minVal) i ++;
            if(arr2[j] == minVal) j ++;
            if(arr3[k] == minVal) k ++;
        }
        return res;
    }
}
```
55.
